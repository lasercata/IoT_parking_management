#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''Manages API authentication with JWT (that are generated by the frontend)'''

##-Imports
from flask import request, jsonify
from functools import wraps
import jwt

import os
from dotenv import load_dotenv

from src.services.database_service import DatabaseService


##-Init
# Construct the path to the .env file in the parent directory
dotenv_path = os.path.join(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
    '.env'
)
# Load the .env file from the parent directory
load_dotenv(dotenv_path)

SECRET_KEY = os.environ.get('JWT_SHARED_TOKEN')


##-Decoder
def decode_token() -> dict[str, str]:
    '''
    Tries to decode the token and return its content.

    Out:
        payload     if successful
        ValueError  Otherwise
    '''

    token = None
    if 'Authorization' in request.headers:
        token = request.headers['Authorization']
    
    # If no token, return unauthorized
    if not token:
        raise ValueError('Authentication Token is missing!')
    
    try:
        # Decode the token
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload

    except jwt.ExpiredSignatureError:
        raise ValueError('Token has expired!')

    except jwt.InvalidTokenError:
        raise ValueError('Invalid token!')

def is_admin() -> bool:
    '''
    Tries to decode the token (using `decode_token`) and checks if it is from an admin.

    Out:
        True       if token is owned by an admin
        False      if not
        ValueError if error while decoding
    '''

    token_payload = decode_token()
    return token_payload['is_admin']

##-Decorator
def token_required(only_admins: bool = False):
    '''
    Creates a decorator that ensure that the connected user possesses a valid token.

    In:
        - only_admins: if True, restrict access only to admins. Otherwise, restrict access to token bearers.
    '''

    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            try:
                payload = decode_token()

            except ValueError as err:
                return jsonify({'message': str(err)}), 401

            # Privilege check
            if only_admins and not payload['is_admin']:
                return jsonify({'message': 'Only admins can access this resource'}), 403

            # If we get here, token is valid
            return f(*args, **kwargs)
        
        return decorated

    return decorator

##-Node authentication
def authenticate_node(db_service: DatabaseService, node_id: str, secret: str) -> bool:
    '''
    Authenticates the node `node_id` by comparing the given secret with the one stored in the database.

    In:
        - db_service: `current_app.config['DB_SERVICE']`
        - node_id: the ID of the node requesting authentication
        - secret: the secret token saved in the node

    Out:
        True        if the node is authenticated
        False       otherwise
        ValueError  if node not found
    '''

    # Get the node secret from DB
    node = db_service.get_dr('node', node_id)
    if node is None:
        raise ValueError('node not found')

    db_token = node['profile']['token']

    return db_token == secret

